\documentclass[../main.tex]{subfiles}
\begin{document} \label{sec:the_algorithm}

В \cite{kusmierek_2007} был представлен населяющий алгоритм для системы $\lambda_\wedge$. Однако этот  алгоритм описан недостаточно полно, что выяснилось при его реализации. Кроме того, алгоритм и доказательство его корректности содержат ошибку. Данная работа устраняет эти неточности и ошибки. Алгоритм для $\lambda_{\wedge \leqslant}$ является модификацией алгоритма из \cite{kusmierek_2007}, поэтому сначала рассмотрим его (в исправленном варианте).


\subsection{Населяющий алгоритм для $\lambda_\wedge$}

\begin{algorithm} \label{алгоритм без эты}

В процессе алгоритма решается система из нескольких задач: $[\Gamma_1 \vdash X : \tau_1 ,\dots, \Gamma_n \vdash X : \tau_n]$. Решением системы является терм $X$, удовлетворяющий всем утверждениям типизации одновременно. При этом поддерживается инвариант: все задачи системы имеют общий набор переменных в контексте (при этом одной и той же типовой переменной могут соответствовать разные типы в разных контекстах). Алгоритм заключается в применении следующих преобразований до тех пор, пока это возможно:
\begin{itemize}
    \item $1$. Один из типов $\tau_i$ -- пересечение ($\tau_i = \sigma \wedge \rho$). Тогда $i$-я задача $\Gamma_i \vdash X : \tau_i$ заменяется двумя:  $\Gamma_i \vdash X : \sigma$ и $\Gamma_i \vdash X : \rho$. Таким образом, размер системы увеличивается
     \item $2$. Все типы $\tau_i$ стрелочные  ($\tau_i = \sigma_i \to \rho_i$, $i = 1 \dots n$). Тогда решение системы --  $X = \lambda x.X'$, где $X'$ -- решение новой системы  $[(\Gamma_1, x:\sigma_1 \vdash X' : \rho_1) ,\dots, (\Gamma_n, x:\sigma_n \vdash X' : \rho_n)]$. То есть в этом случае во всех типах редуцируется первый аргумент. 
     \item $3_{\wedge}$. Один из типов $\tau_i$ -- это типовая переменная. Тогда $X$ не может быть абстракцией и должен быть (возможно пустой) аппликацией некоторой головной переменной, взятой из контекста, к термам. В этом случае необходимо недетерминированно выбрать из контекста головную переменную $x$ и число $k \geqslant 0$ таким образом, чтобы  $\Gamma_i \vdash \lambda z_1 \dots z_k . x z_1 \dots z_k : \rho_i^1 \to \dots \to \rho_i^k \to \tau_i$ для всех $i = 1 \dots n$. Тогда решение --  $X = x Z^1 \dots Z^k$, где  $Z^i$ -- решение системы $[(\Gamma_1 \vdash Z^i : \rho_1^i) ,\dots, (\Gamma_n \vdash Z^i : \rho_n^i)]$. Здесь $k$ систем независимы и могут быть решены параллельно.
\end{itemize}

Если ни одно из преобразований применить невозможно, то система не имеет решения. 
<<Точка выхода>> из алгоритма -- тот случай в преобразовании 3, при котором $k = 0$, при этом решением является переменная.
    
\end{algorithm}


В данном алгоритме не совсем ясным является преобразование $3_{\wedge}$: как именно выбираются $\rho_i^j$. Типизация $\Gamma_i \vdash \lambda z_1 \dots z_k . x z_1 \dots z_k : \rho_i^1 \to \dots \to \rho_i^k \to \tau_i$ не гарантирует того, что тип $x$ в контексте $\Gamma_i$ обязан быть $ \rho_i^1 \to \dots \to \rho_i^k \to \tau_i$. 

\subsection{Населяющий алгоритм для $\lambda_{\wedge \eta}$}

Алгоритм для системы с $\eta$-правилом во многом повторяет алгоритм для $\lambda_\wedge$. Принципиальное отличие заключается в преобразовании $3$.
\begin{algorithm} \label{alg} 
Поддерживается система из нескольких задач: $\Gamma_1 \vdash X : \tau_1 ,\dots, \Gamma_n \vdash X : \tau_n$. До тех пор, пока это возможно, выполняется одно из четырёх преобразований: 

\begin{itemize}

     \item $0$. Один из типов $\tau_i$ не находится в нормальной форме. Тогда заменим $\tau_i$ на $\tau_i^*$.
     \item Шаги $1$ и $2$ аналогичны Алгоритму \ref{алгоритм без эты}.
     
     \item $3_{\wedge \eta}$. Один из типов $\tau_i$ -- это типовая переменная. Тогда $X$ не может быть абстракцией и должен быть (возможно, пустой) аппликацией некоторой головной переменной, взятой из контекста, к термам. В этом случае необходимо недетерминированно выбрать переменную $x$ и число $k \geqslant 0$ таким образом, чтобы  $\Gamma_i \vdash x : \rho_i^1 \to \dots \to \rho_i^k \to \tau_i$ для всех $i = 1 \dots n$. Тогда решение --  $X = x Z^1 \dots Z^k$, где $Z^i$ -- решение системы $(\Gamma_1 \vdash Z^i : \rho_1^i) ,\dots, (\Gamma_n \vdash Z^i : \rho_n^i)$. Здесь $k$ систем независимы и могут быть решены параллельно.
     
     Следствие~\ref{прояснение} описывает, как именно устроен недетерминированный выбор $x$, $k$ и $\rho_i^j$.
     
\end{itemize}

Аналогично алгоритму \ref{алгоритм без эты}, если ни одно из преобразований применить невозможно, система не имеет решения. 

\end{algorithm}

\subsection{Отличия алгоритмов}

В \cite{kusmierek_2007} в качестве населяющего алгоритма для системы $\lambda_\wedge$ приведён алгоритм, почти совпадающий с Алгоритмом 3, описанным выше. Однако на следующем примере можно убедиться, что данный алгоритм не является полным в системе $\lambda_\wedge$.

Пусть задача -- $p \colon \alpha \to \beta \wedge \gamma, q \colon \alpha \vdash X \colon \beta$. Алгоритм должен произвести преобразование $3_{\wedge \eta}$, но в контексте нет такого $x$, что $p \colon \alpha \to \beta \wedge \gamma, q \colon \alpha \vdash x \colon \dots \to \beta$, поскольку, согласно Лемме \ref{существенность: типизация}, утверждение о типизации $p \colon \alpha \to \beta \wedge \gamma \vdash p \colon \alpha \to \beta$ неверно в $\lambda_\wedge$. Поэтому алгоритм завершится, не найдя решение $X = pq$. 
Но преобразование $3_\wedge$ применить можно: $p \colon \alpha \to \beta \wedge \gamma, q \colon \alpha \vdash \lambda z . pz \colon \alpha \to \beta$. Здесь $\lambda$ позволяет применить $(I \to)$ и удалить $\to$.

\subsection{Выводы и результаты по главе}

В данной главе был рассмотрен населяющий Алгоритм~\ref{алгоритм без эты} для системы $\lambda_\wedge$, описанный ранее в \cite{kusmierek_2007}, а также приведён оригинальный населяющий Алгоритм~\ref{alg} для системы $\lambda_{\wedge \eta}$. Ключевым отличием алгоритмов является преобразование $3$, некоторые подробности которого для Алгоритма~\ref{alg} описывает следствие~\ref{прояснение}.

Довольно очевидным является тот факт, что результат, выдаваемый алгоритмами корректен: если на входе $\tau$ алгоритм выдаёт терм $x$, то $\emptyset \vdash x \colon \tau$. Однако кроме корректности нас интересует полнота (если тип обитаем, то алгоритм находит его обитателей) и завершаемость (если тип необитаем, алгоритм завершится за конечное число операций). Оказывается, завершаемость в таком виде доказать невозможно, поскольку в общем случае задача населённости для этой системы типов неразрешима \cite{urzyczyn_1999}. Но, при условии некоторых ограничений на входные типы, алгоритм всё же гарантированно останавливается за конечное время. Описанию этих ограничений, а также доказательству корректности, полноты и завершаемости посвящена следующая глава.

\end{document}