\documentclass[../main.tex]{subfiles}
\begin{document}



В этом разделе будут доказаны свойства Алгоритма \ref{alg} для системы $\lambda_\wedge_\eta$. А именно, его корректность (soundness), полнота (completeness), завершаемость (termination) на типах ранга $\leqslant 2$.


\subsection{Корректность}

Корректность алгоритма означает, что ответ, данный им, удовлетворяет входным условиям. То есть если некий терм был найден, то он действительно типизируется заданным типом.

\begin{theorem}[Soundness]
Если алгоритм находит терм $M$ для входного типа $\tau$, то $\vdash M \colon \tau$
\end{theorem}
\begin{proof}
Усилим утверждение: докажем, что алгоритм корректно решает систему задач. Доказательство -- индукция по количеству шагов алгоритма. В базе индукции используется аксиома $(Ax)$. В переходах индукции в шагах $1$, $2$ и $3_{\wedge \eta}$ используются правила вывода $(I \wedge)$, $(I \to)$ и $(E \to)$ соответственно.
\end{proof}

\subsection{Полнота}

Полнота -- гораздо более содержательное свойство. Оно означает, что если существует терм заданного типа, то алгоритм обязательно найдёт или его, или другой терм этого типа. В нашем случае это будет терм в так называемой длинной форме.
Далее будет доказан ряд лемм, имеющих отношение к преобразованию $3_{\wedge \eta}$ и проясняющих его смысл. 

\begin{lemma} \label{необходимая типизация}

Пусть $x$ -- переменная, $M_i$ -- термы, $\tau$ -- тип в нормальной форме без пересечений на верхнем уровне (см. следствие \ref{normal form unit}). Тогда равносильно: 
    $$\Gamma \vdash x M_1 \dots M_k \colon \tau$$ 
    $$\iff$$
    $$\Gamma \vdash x \colon \alpha_1 \to \dots \to \alpha_k \to \tau \text{ и } \Gamma \vdash M_i \colon \alpha_i \text{ для } i = 1 \dots k$$
\end{lemma}

\begin{proof}
    Докажем равносильность в обе стороны.
\begin{itemize}
    \item [\Leftarrow )] применяя правило $(E\to)$ $k$ раз, получаем в точности необходимое утверждение о типизации.
    \item [\Rightarrow )] Если $k = 0$, то утверждение леммы очевидно. Иначе докажем индукцией по размеру дерева вывода (анализируя дерево с конца, аналогично доказательству Леммы \ref{существенность: типизация}). Рассуждения будет удобнее провести в системе $\lambda_{\wedge \leqslant}$~(\ref{rules subtype}), поскольку в ней меньше правил вывода.
    
    
    Какое правило вывода могло быть применено последним, чтобы получить утверждение $\Gamma \vdash x M_1 \dots M_k \colon \tau$? Это не могло быть $(Ax)$, так как оно типизирует переменную; это не могло быть $(I \to)$, так как оно типизирует лямбда абстракцию; это не могло быть $(I \wedge)$, поскольку в $\tau$ нет пересечений на верхнем уровне. Таким образом, могли быть применены только два правила: $(\leqslant)$ или $(E \to)$. 
    
    Согласно Лемме~\ref{normal form unit}, $\tau$ имеет вид $\rho_1 \to \cdots \to \rho_m \to \beta$, где $\beta$ --- типовая переменная. По Лемме~\ref{подтип стрелки}, подтип $\tau$ тогда обязан иметь вид $\varphi_1 \wedge (\ob{\rho_1} \to \varphi_2 \wedge (\ob{\rho_2} \to \varphi_3 \wedge \dots(\ob{\rho_k} \to \beta)\dots))$. К такой типизации можно или снова применить $(\leqslant)$, получив нечто такой же формы (поскольку $\ub{\ub{\tau}} = \ub{\tau}$) или применить $(I \wedge)$, получив в одной из веток нечто той же формы. Так или иначе, в определённый момент будет применено $(E \to)$ к $\ub{\tau}$.
    
    Таким образом, в общем случае дерево вывода имеет следующий вид: 
    $$\infer*[(\leqslant), (I \wedge)]{\Gamma \vdash x M_1 \dots M_k \colon \tau}
                          {\infer[(E \to)]{\Gamma \vdash x M_1 \dots M_k \colon \ub{\tau}}
                                                {\infer*{\Gamma \vdash x M_1 \dots M_{k - 1} \colon \alpha_k \to \ub{\tau}}{} &
                                                 \infer*{\Gamma \vdash M_k \colon \alpha_k}}{}}$$
    Поскольку $\alpha_k \to \ub{\tau} \leqslant \alpha_k \to \tau$, верно утверждение о типизации $\Gamma \vdash x M_1 \dots M_{k - 1} \colon \alpha_k \to \tau$, которое подходит под условия леммы. Поэтому, применив те же рассуждения ещё $k - 1$ раз, получим $\Gamma \vdash x \colon \alpha_1 \to \ub{\alpha_2 \to \cdots \to \alpha_k \to \tau}$, а также $\Gamma \vdash M_i \colon \alpha_i \text{ для } i = 1 \dots k$. 
    
    Легко видеть, что $\alpha_1 \to \ub{\alpha_2 \to \cdots \to \alpha_k \to \tau} \leqslant \alpha_1 \to \cdots \to \alpha_k \to \tau$, поэтому мы можем применить $(\leqslant)$ и получить необходимую типизацию.
\end{itemize}
\end{proof}

\begin{notice}
    Условие о том, что $\tau$ -- тип без пересечений на верхнем уровне, существенно. Так, например, для $\Gamma = \{x \colon (\alpha \to \beta) \wedge (\gamma \to \delta), M \colon (\alpha \wedge \gamma)  \}$, $\Gamma \vdash xM \colon \beta \wedge \gamma$, но при этом $\Gamma \nvdash x \colon \cdots \to \beta \wedge \gamma$.
\end{notice}

\begin{notice}
    Условие о том, что $\tau$ -- тип в нормальной форме, существенно. Так, например, для $\Gamma = \{x \colon (\alpha \to \varphi \to \beta) \wedge (\gamma \to \varphi \to \delta), M \colon (\alpha \wedge \gamma)  \}$, $\Gamma \vdash xM \colon \varphi \to (\beta \wedge \gamma)$, но при этом $\Gamma \nvdash x \colon \cdots \to \varphi \to (\beta \wedge \gamma)$.
\end{notice}

\begin{corollary} \label{в контексте} 
    В условиях предыдущей леммы, при выполнении любой из равносильных частей, $\Gamma \ni x \colon \ub{\alpha_1 \to \cdots \to \alpha_k \to \tau}$,
\end{corollary}

\begin{proof}
Для доказательства достаточно провести ещё один шаг в рассуждениях леммы, за тем лишь исключением, что вместо $(E \to)$ должно быть применено $(Ax)$, что и гарантирует наличие нужной типизации в контексте.
\end{proof}

\begin{corollary} \label{в контексте при разложении}
    В условиях предыдущей леммы, при выполнении любой из равносильных частей, в контексте $\Gamma$ есть типизация $x \colon \sigma$ такая, что $\hat{\sigma^*} \ni \ob{\alpha_1} \to \cdots \to \ob{\alpha_k} \to \ub{\tau}$.
    
    В частности, если $\tau$ --- типовая переменная, то $\hat{\sigma^*} \ni \ \ob{\alpha_1} \to \cdots \to \ob{\alpha_k}  \to \tau$.
\end{corollary}
\begin{proof}
    Воспользуемся предыдущим следствием и тем наблюдением, что 
    $\ub{\alpha_1 \to \cdots \to \alpha_k \to \tau} = \varphi_1 \wedge (\ob{\alpha_1} \to \varphi_2 \wedge (\ob{\alpha_2} \to \varphi_3 \wedge \dots(\ob{\alpha_k} \to  \ub{\tau})\dots))$
\end{proof}


Следующее следствие проясняет, как с алгоритмической точки зрения устроено преобразование $3_{\wedge \eta}$ в Алгоритме \ref{alg}. А именно, как выбрать $x$, $k$ и $\rho_i^j$.

\begin{corollary} \label{прояснение}
    Пусть в шаге $3_{\wedge \eta}$ Алгоритма~\ref{alg}, $\tau_i$ -- типовая переменная. Тогда для того, чтобы выбрать $x$, $k$ и $\rho_i^j$ ($j = 1 \dots k$), достаточно перебрать все элементы $(x \colon \sigma)$ контекста такие, что $\hat{\sigma^*}$ содержит тип, заканчивающийся на $\tau_i$, то есть имеющий вид $\rho_i^1 \to \cdots \to \rho_i^k \to \tau_i$. 
    
    Для того, чтобы проверить, что выбранный $x$ удовлетворяет всем остальным задачам, а также чтобы подобрать $\rho_t^j$ (для всех $t \neq i$ и $j = 1 \dots k$), достаточно найти среди элементов $\hat{\sigma^*}$ (где $\Gamma_t \ni (x \colon \sigma)$) типы, у которых после <<отщепления>> $k$ аргументов остаётся подтип $\tau_t$, то есть имеющие вид $\rho_t^1 \to \cdots \to \rho_t^k \to \tau_t'$, где $\tau_t' \leqslant \tau_t$.
    
\end{corollary}

\begin{theorem}[Completeness]
Если у системы задач существует решение, то Алгоритм \ref{alg} найдёт его или другое решение. 
\end{theorem}
\begin{proof}
Доказательство -- индукция по размеру наибольшего типа в задачах системы. 
Пусть дана система $T = [\Gamma_1 \vdash X \colon \tau_1 ,\dots, \Gamma_n \vdash X \colon \tau_n]$, а $M$ --- её решение.

Если один из $\tau_i$ -- тип-пересечение, алгоритм разобьёт его на два. При этом решение $M$ останется решением системы, но уменьшится размер задач системы, поэтому можно применить индукционное предположение. Аналогичные рассуждения можно провести в случае, если один из $\tau_i$ не находится в нормальной форме (при этом, чтобы размеры типов уменьшились, нужно снять пересечения, сделав несколько раз преобразование 1).

Пусть ни один из типов $\tau_i$ не является пересечением. 
Рассмотрим, как может быть устроено $M$.
\begin{itemize}
    \item  $M = \lambda x . M'$. 
    
    Тогда все типы в задачах должны быть стрелочные: $\tau_i = \alpha_i \to \beta_i$. Алгоритм перейдёт к системе $T = [\Gamma_1, x \colon \alpha_1 \vdash X' \colon \beta_1 ,\dots, \Gamma_n, x \colon \alpha_n \vdash X' \colon \beta_n]$, у которой существует решение $M'$.
    
    \item  $M = x M_1 M_2 \dots M_k$.
        \begin{itemize}
            \item Пусть все типы в задачах стрелочные: $\tau_i = \alpha_i \to \beta_i$. 
                Тогда алгоритм, аналогично предыдущему пункту, перейдёт к системе $T = [\Gamma_1, y \colon \alpha_1 \vdash X' \colon \beta_1 ,\dots, \Gamma_n, y \colon \alpha_n \vdash X' \colon \beta_n]$.  решение которой --- $x M_1 M_2 \dots M_k y$.
            
            \item Пусть один из типов в задачах -- переменная: $\tau_i = \beta$. По Лемме~\ref{необходимая типизация}, верно следующее: $\Gamma_i \vdash x \colon \alpha_i^1 \to \dots \to \alpha_i^k \to \tau_i \text{ и } \Gamma_i \vdash M_j \colon \alpha_i^j \text{ для } i = 1 \dots n, j = 1 \dots k$. 
            Поэтому, выбрав $k$ и $x$, алгоритм перейдёт к системам $T_j = [(\Gamma_1 \vdash X_j : \ob{\alpha_1^j}) ,\dots, (\Gamma_n \vdash X_j : \ob{\alpha_n^j})]$. $M_j$ является решением $j$-й системы.

        \end{itemize}
        
\end{itemize}

\end{proof}

\subsection{Завершаемость}
В предыдущих разделах было доказано, что Алгоритм~\ref{alg} выдаёт корректное решение, если оно существует. Однако от алгоритма требуется, чтобы он завершался за конечное число шагов, даже если тип пустой. В текущей системе типов такие гарантии получить невозможно: задача обитаемости неразрешима \cite{urzyczyn_99}.
Для обеспечения завершаемости можно ограничить множество входных типов, а именно ввести ограничение на их ранг. 

Понятие ранга вводится в \cite{leivant_83} и определяется как максимальная глубина вложенности <<$\wedge$>> в качестве левого аргумента <<$\to$>>. Более формальное определение следующее:

\begin{definition}

\begin{align*}
    rank(\tau) &= 0 \\
               & \text{если $\tau$ -- тип без пересечений}\\
    rank(\sigma \wedge \tau) &= max(1, rank(\sigma), rank(\tau))\\
    rank(\sigma \to \tau) &= max(1 + rank(\sigma), rank(\tau))\\
               & \text{если $rank(\sigma) > 0$ или $rank(\tau) > 0$}
\end{align*}

\end{definition}

Так, например, $rank(\varphi \wedge (\tau \to (\alpha \wedge \beta) \to \gamma)) = 1$

\begin{lemma}\label{arrow rank}
Если $rank(\rho_1 \to \cdots \to \rho_k \to \tau) = r > 0$, то $rank(\rho_i) < r$ для всех $i = 1 \dots k$.
\end{lemma}

Следующее доказательство во многом повторяет доказательство завершаемости из \cite{kusmierek_07}.
\begin{theorem}[Termination]
Пусть $\tau$ -- тип с рангом не больше двух ($rank(\tau) \leqslant 2$). Тогда Алгоритм~\ref{alg} завершается на входе $\tau$.
\end{theorem}
\begin{proof}
    Пусть $rank(\tau) = 0$, что равносильно тому, что в $\tau$ нет пересечений. Тогда алгоритм завершится после линейного числа преобразований $2$ (и затем одного $3_{\wedge \eta}$).
    
    Проследим за рангами целевых типов $\tau_i$ и типов в контекстах $\Gamma_i$.
    
    В преобразованиях $0$ и $1$ контексты не изменяются, а ранги типов в задачах не увеличиваются.
    
    В преобразовании $2$ ранг типов в задачах не увеличивается. А в контексты попадают 
    типы $\sigma_i$, находящиеся слева от стрелки в типе $\tau_i = \sigma_i \to \rho_i$, а значит, имеющие или нулевой ранг, или хотя бы на $1$ меньший ранг, чем $\tau_i$ (см. Лемму~\ref{arrow rank}). 
    
    В преобразовании $3_{\wedge \eta}$ контексты не изменяются, а в целевыми становятся типы $\alpha_i^j$, являющиеся аргументами в типах из контекстов, а значит, имеющие на $1$ меньший ранг (или нулевой).
    
    Из вышеизложенных соображений следует, что типы в контекстах всегда имеют ранг $\leqslant 1$, поэтому преобразование $3_{\wedge \eta}$ порождает задачи, в которых целевые типы имеют нулевой ранг. Эти задачи решаются за линейное число шагов. 
    Преобразования $0-2$ структурно уменьшают целевые типы, поэтому применяются лишь конечное число раз.
    
    
\end{proof}

\end{document}