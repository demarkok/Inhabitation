\documentclass[../main.tex]{subfiles}
\begin{document} \label{sec:properties}



В этом разделе будут доказаны свойства Алгоритма \ref{alg} для системы $\lambda_{\wedge \eta}$. А именно, его корректность (soundness), полнота (completeness), завершаемость (termination) на типах ранга $\leqslant 2$.


\subsection{Корректность}

Корректность алгоритма означает, что ответ, данный им, удовлетворяет входным условиям. То есть если некий терм был найден, то он действительно типизируется заданным типом.

\begin{theorem}[Soundness] \label{soundness}
Если алгоритм находит терм $M$ для входного типа $\tau$, то $\vdash M \colon \tau$
\end{theorem}
\begin{proof}
Усилим утверждение: докажем, что алгоритм корректно решает систему задач. Доказательство -- индукция по количеству шагов алгоритма. В базе индукции используется аксиома $(Ax)$. В переходах индукции в шагах $1$, $2$ и $3_{\wedge \eta}$ используются правила вывода $(I \wedge)$, $(I \to)$ и $(E \to)$ соответственно.
\end{proof}

\subsection{Полнота}

Полнота -- гораздо более содержательное свойство. Оно означает, что если существует терм заданного типа, то алгоритм обязательно найдёт или его, или другой терм этого типа. В нашем случае это будет терм в так называемой длинной форме.
Далее будет доказан ряд лемм, имеющих отношение к преобразованию $3_{\wedge \eta}$ и проясняющих его смысл. 

\begin{lemma} \label{необходимая типизация}

Пусть $x$ -- переменная, $M_i$ -- термы, $\tau$ -- тип в нормальной форме без пересечений на верхнем уровне (см. следствие \ref{normal form unit}). Тогда равносильно: 
    $$\Gamma \vdash x M_1 \dots M_k \colon \tau$$ 
    $$\iff$$
    $$\Gamma \vdash x \colon \rho_1 \to \dots \to \rho_k \to \tau \text{ и } \Gamma \vdash M_i \colon \rho_i \text{ для } i = 1 \dots k$$
\end{lemma}

\begin{proof}
    Докажем равносильность в обе стороны.
\begin{itemize}
    \item [$\Leftarrow$ )] применяя правило $(E\to)$ $k$ раз, получаем в точности необходимое утверждение о типизации.
    \item [$\Rightarrow$ )] Если $k = 0$, то утверждение леммы очевидно. Иначе докажем индукцией по размеру дерева вывода (анализируя дерево с конца, аналогично доказательству Леммы \ref{существенность: типизация}). Рассуждения будет удобнее провести в системе $\lambda_{\wedge \leqslant}$~(\ref{rules subtype}), поскольку в ней меньше правил вывода.
    
    
    Какое правило вывода могло быть применено последним, чтобы получить утверждение $\Gamma \vdash x M_1 \dots M_k \colon \tau$? Это не могло быть $(Ax)$, так как оно типизирует переменную; это не могло быть $(I \to)$, так как оно типизирует лямбда абстракцию; это не могло быть $(I \wedge)$, поскольку в $\tau$ нет пересечений на верхнем уровне. Таким образом, могли быть применены только два правила: $(\leqslant)$ или $(E \to)$. 
    
    Согласно Лемме~\ref{normal form unit}, $\tau$ имеет вид $\sigma_1 \to \cdots \to \sigma_m \to \beta$, где $\beta$ --- типовая переменная. По Следствию~\ref{подтип стрелки}, подтип $\tau$ тогда обязан иметь вид $\varphi_1 \wedge (\ob{\sigma_1} \to \varphi_2 \wedge (\ob{\sigma_2} \to \varphi_3 \wedge \dots(\ob{\sigma_k} \to \beta)\dots))$. К такой типизации можно или снова применить $(\leqslant)$, получив нечто такой же формы (поскольку $\ub{\ub{\tau}} = \ub{\tau}$) или применить $(I \wedge)$, получив в одной из веток нечто той же формы. Так или иначе, в определённый момент будет применено $(E \to)$ к $\ub{\tau}$.
    
    Таким образом, в общем случае дерево вывода имеет следующий вид: 
    $$\infer*[(\leqslant), (I \wedge)]{\Gamma \vdash x M_1 \dots M_k \colon \tau}
                          {\infer[(E \to)]{\Gamma \vdash x M_1 \dots M_k \colon \ub{\tau}}
                          {\infer*{\Gamma \vdash x M_1 \dots M_{k - 1} \colon \rho_k \to \ub{\tau}}{} & \infer*{\Gamma \vdash M_k \colon \rho_k}}{}}$$
    Поскольку $\rho_k \to \ub{\tau} \leqslant \rho_k \to \tau$, верно утверждение о типизации $\Gamma \vdash x M_1 \dots M_{k - 1} \colon \rho_k \to \tau$, которое подходит под условия леммы. Поэтому, применив те же рассуждения ещё $k - 1$ раз, получим $\Gamma \vdash x \colon \rho_1 \to \ub{\rho_2 \to \cdots \to \rho_k \to \tau}$, а также $\Gamma \vdash M_i \colon \rho_i \text{ для } i = 1 \dots k$. 
    
    Легко видеть, что $\rho_1 \to \ub{\rho_2 \to \cdots \to \rho_k \to \tau} \leqslant \rho_1 \to \cdots \to \rho_k \to \tau$, поэтому мы можем применить $(\leqslant)$ и получить необходимую типизацию.
\end{itemize}
\end{proof}

\begin{notice}
    Условие о том, что $\tau$ -- тип без пересечений на верхнем уровне, существенно. Так, например, для $\Gamma = \{x \colon (\alpha \to \beta) \wedge (\gamma \to \delta), M \colon (\alpha \wedge \gamma)  \}$, $\Gamma \vdash xM \colon \beta \wedge \gamma$, но при этом $\Gamma \nvdash x \colon \cdots \to \beta \wedge \gamma$.
\end{notice}

\begin{notice}
    Условие о том, что $\tau$ -- тип в нормальной форме, существенно. Так, например, для $\Gamma = \{x \colon (\alpha \to \varphi \to \beta) \wedge (\gamma \to \varphi \to \delta), M \colon (\alpha \wedge \gamma)  \}$, $\Gamma \vdash xM \colon \varphi \to (\beta \wedge \gamma)$, но при этом $\Gamma \nvdash x \colon \cdots \to \varphi \to (\beta \wedge \gamma)$.
\end{notice}

\begin{corollary} \label{в контексте} 
    В условиях предыдущей леммы, при выполнении любой из равносильных частей, $\Gamma \ni x \colon \ub{\rho_1 \to \cdots \to \rho_k \to \tau}$,
\end{corollary}

\begin{proof}
Для доказательства достаточно провести ещё один шаг в рассуждениях леммы, за тем лишь исключением, что вместо $(E \to)$ должно быть применено $(Ax)$, что и гарантирует наличие нужной типизации в контексте.
\end{proof}

\begin{corollary} \label{в контексте при разложении}
    В условиях предыдущей леммы, при выполнении любой из равносильных частей, в контексте $\Gamma$ есть типизация $x \colon \pi$ такая, что $\hat{\pi^*} \ni \ob{\rho_1} \to \cdots \to \ob{\rho_k} \to \ub{\tau}$.
    
    В частности, если $\tau$ --- типовая переменная, то $\hat{\pi^*} \ni \ \ob{\rho_1} \to \cdots \to \ob{\rho_k}  \to \tau$.
\end{corollary}
\begin{proof}
    Воспользуемся предыдущим следствием и тем наблюдением, что 
    $\ub{\rho_1 \to \cdots \to \rho_k \to \tau} = \varphi_1 \wedge (\ob{\rho_1} \to \varphi_2 \wedge (\ob{\rho_2} \to \varphi_3 \wedge \dots(\ob{\rho_k} \to  \ub{\tau})\dots))$
\end{proof}


Следующее следствие проясняет, как с алгоритмической точки зрения устроено преобразование $3_{\wedge \eta}$ в Алгоритме \ref{alg}. А именно, как выбрать $x$, $k$ и $\rho_i^j$.

\begin{corollary} \label{прояснение}
    Пусть в шаге $3_{\wedge \eta}$ Алгоритма~\ref{alg}, $\tau_i$ -- типовая переменная. Тогда для того, чтобы выбрать $x$, $k$ и $\rho_i^j$ ($j = 1 \dots k$), достаточно перебрать все элементы $(x \colon \pi)$ контекста такие, что $\hat{\pi^*}$ содержит тип, заканчивающийся на $\tau_i$, то есть имеющий вид $\rho_i^1 \to \cdots \to \rho_i^k \to \tau_i$. 
    
    Для того, чтобы проверить, что выбранный $x$ удовлетворяет всем остальным задачам, а также чтобы подобрать $\rho_t^j$ (для всех $t \neq i$ и $j = 1 \dots k$), достаточно найти среди элементов $\hat{\pi^*}$ (где $\Gamma_t \ni (x \colon \pi)$) типы, у которых после <<отщепления>> $k$ аргументов остаётся подтип $\tau_t$, то есть имеющие вид $\rho_t^1 \to \cdots \to \rho_t^k \to \tau_t'$, где $\tau_t' \leqslant \tau_t$.
    
\end{corollary}

\begin{theorem}[Completeness] \label{completeness}
Если у системы задач существует решение, то Алгоритм \ref{alg} найдёт его или другое решение. 
\end{theorem}
\begin{proof}
Доказательство -- индукция по упорядоченной паре: длина типа-ответа и суммарная мощность (см. Определение~\ref{typesize}) целевых типов в задачах системы.
Пусть дана система $T = [\Gamma_1 \vdash X \colon \tau_1 ,\dots, \Gamma_n \vdash X \colon \tau_n]$, а $M$ --- её решение.

Если один из $\tau_i$ -- тип-пересечение, алгоритм разобьёт его на два. При этом $M$ по-прежнему будет решением, но уменьшится суммарная мощность типов в задачах системы, поэтому можно применить индукционное предположение. Аналогичные рассуждения можно провести в случае, если один из $\tau_i$ не находится в нормальной форме (при этом размеры целевых типов уменьшатся после ещё нескольких шагов алгоритма, когда будут сделаны преобразования $1$ и сняты пересечения на верхнем уровне).

Пусть ни один из типов $\tau_i$ не является пересечением. 
Рассмотрим, как может быть устроено $M$.
\begin{enumerate}
    \item $M = \lambda x . M'$. 
    
    Тогда все типы в задачах должны быть стрелочные: $\tau_i = \sigma_i \to \rho_i$. Алгоритм перейдёт к системе $T = [\Gamma_1, x \colon \sigma_1 \vdash X' \colon \rho_1 ,\dots, \Gamma_n, x \colon \sigma_n \vdash X' \colon \rho_n]$, у которой существует решение $M'$.
    
    В этом случае индукционный переход применим, поскольку длина терма-решения уменьшается.
    
    \item $M = x M_1 M_2 \dots M_k$
        \begin{enumerate}
            \item \label{case:a} Пусть все типы в задачах стрелочные: $\tau_i = \sigma_i \to \rho_i$. 
                Тогда алгоритм, аналогично предыдущему пункту, перейдёт к системе $T = [\Gamma_1, y \colon \sigma_1 \vdash X' \colon \rho_1 ,\dots, \Gamma_n, y \colon \sigma_n \vdash X' \colon \rho_n]$.  решение которой --- $x M_1 M_2 \dots M_k y$.
            
            Стоит отметить, что в этом случае длина решения увеличивается, поэтому индукционное предположение нельзя применить сразу. Ниже этот вопрос проясняется.
            
            \item \label{case:b} Пусть один из типов в задачах -- переменная: $\tau_i = \beta$. По Лемме~\ref{необходимая типизация}, верно следующее: $\Gamma_i \vdash x \colon \sigma_i^1 \to \dots \to \sigma_i^k \to \tau_i \text{ и } \Gamma_i \vdash M_j \colon \sigma_i^j \text{ для } i = 1 \dots n, j = 1 \dots k$. 
            Поэтому, выбрав $k$ и $x$, алгоритм перейдёт к системам $T_j = [(\Gamma_1 \vdash X_j : \sigma_1^j') ,\dots, (\Gamma_n \vdash X_j : \sigma_n^j)]$, где $\sigma_i^j'$ -- некоторый надтип $\sigma_i^j$. $M_j$ является решением $j$-й системы.
        \end{enumerate}
        
        Алгоритм устроен таким образом, что в случае, когда $M = x M_1 M_2 \dots M_k$, сначала несколько раз (конечное число) выполняется пункт \ref{case:a}, а затем один раз выполняется пункт \ref{case:b}. При этом если $k > 0$, то длины решений в задачах, порождаемых пунктом \ref{case:b}, строго меньше длины изначального решения $M$, поэтому индукционный переход применим. 
        
        Если $k = 0$, по Следствию~\ref{в контексте}, $\Gamma_i \ni x \colon \tau_i'$ для некоторых $\tau_i' \leqslant \tau_i$. Алгоритм работает таким образом, что далее решение $M$ всегда будет некоторой новой переменной (если не учитывать шаги \ref{case:a}, а сразу переходить к результату пункта \ref{case:b}). При этом легко видеть, что целевые типы будет порождаться при <<разборе>> $\tau_i'$, и мощности целевых типов будут уменьшаться с каждой итерацией. Если целевой тип -- переменная, алгоритм завершится, найдя в контексте нужную типизацию.
        
\end{enumerate}

\end{proof}

\subsection{Завершаемость}
В предыдущих разделах было доказано, что Алгоритм~\ref{alg} выдаёт корректное решение, если оно существует. Однако от алгоритма требуется, чтобы он завершался за конечное число шагов, даже если тип пустой. В текущей системе типов такие гарантии получить невозможно: задача обитаемости неразрешима \cite{urzyczyn_1999}. 
Для обеспечения завершаемости можно ограничить множество входных типов, а именно ввести ограничение на их ранг. 

Понятие ранга вводится в \cite{leivant_1983} и определяется как максимальная глубина вложенности <<$\wedge$>> в качестве левого аргумента <<$\to$>>. Более формальное определение следующее:

\begin{definition}

\begin{align*}
    rank(\tau) &= 0 \\
               & \text{если $\tau$ -- тип без пересечений}\\
    rank(\sigma \wedge \tau) &= max(1, rank(\sigma), rank(\tau))\\
    rank(\sigma \to \tau) &= max(1 + rank(\sigma), rank(\tau))\\
               & \text{если $rank(\sigma) > 0$ или $rank(\tau) > 0$}
\end{align*}

\end{definition}

Так, например, $rank(\varphi \wedge (\tau \to (\alpha \wedge \beta) \to \gamma)) = 1$

\begin{lemma}\label{arrow rank}
Если $rank(\rho_1 \to \cdots \to \rho_k \to \tau) = r > 0$, то $rank(\rho_i) < r$ для всех $i = 1 \dots k$.
\end{lemma}

Следующее доказательство во многом повторяет доказательство завершаемости из \cite{kusmierek_2007}.
\begin{theorem}[Termination] \label{termination}
Пусть $\tau$ -- тип с рангом не больше двух ($rank(\tau) \leqslant 2$). Тогда Алгоритм~\ref{alg} завершается на входе $\tau$.
\end{theorem}
\begin{proof}
    Пусть $rank(\tau) = 0$, что равносильно тому, что в $\tau$ нет пересечений. Тогда алгоритм завершится после линейного числа преобразований $2$ (и затем одного $3_{\wedge \eta}$).
    
    Проследим за рангами целевых типов $\tau_i$ и типов в контекстах $\Gamma_i$.
    
    В преобразованиях $0$ и $1$ контексты не изменяются, а ранги типов в задачах не увеличиваются.
    
    В преобразовании $2$ ранг типов в задачах не увеличивается. А в контексты попадают 
    типы $\sigma_i$, находящиеся слева от стрелки в типе $\tau_i = \sigma_i \to \rho_i$, а значит, имеющие или нулевой ранг, или хотя бы на $1$ меньший ранг, чем $\tau_i$ (см. Лемму~\ref{arrow rank}). 
    
    В преобразовании $3_{\wedge \eta}$ контексты не изменяются, а в целевыми становятся типы $\alpha_i^j$, являющиеся аргументами в типах из контекстов, а значит, имеющие на $1$ меньший ранг (или нулевой).
    
    Из вышеизложенных соображений следует, что типы в контекстах всегда имеют ранг $\leqslant 1$, поэтому преобразование $3_{\wedge \eta}$ порождает задачи, в которых целевые типы имеют нулевой ранг. Эти задачи решаются за линейное число шагов. 
    Преобразования $1-2$ уменьшают суммарную мощность (см. Определение~\ref{typesize}) целевых типов, а за преобразованием $0$ всегда следует преобразование $1$, поэтому преобразования $1-2$ могут применяться (перед преобразованием $3$) лишь конечное число раз.
    
    
\end{proof}

\subsection{Выводы и результаты по главе}

В данной главе для Алгоритма~\ref{alg} были показаны корректность (Теорема~\ref{soundness}) и полнота (Теорема~\ref{completeness}). Кроме того, была доказана важная Лемма~\ref{необходимая типизация}, использующаяся в доказательстве полноты, и Следствия (\ref{в контексте}, \ref{в контексте при разложении} и \ref{прояснение}) из неё. Эти следствия позволяют реализовать преобразование $3_{\wedge \eta}$, явным образом перебирая головную переменную в контексте. Также было введено понятие ранга типа и доказана завершаемость алгоритма для типов, имеющих ранг $\leqslant 2$.

Таким образом, в главе доказано, что задача обитаемости является разрешимой в системе $\lambda_{\wedge \eta}$ для типов ранга $\leqslant 2$.

\end{document}




